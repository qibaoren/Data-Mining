python类的总结
OOP:Object-Oriented Programming
两种对象：类，类的实例，类树中两种对象完全等价,各自拥有独立的命名空间。
继承：实例继承类，类继承类
#############################################################################
类树：
{[C2].x,.y}        {[C3].w,.z}    C2与C1是父类
        {[C1].x,.y}           C1是类
{[I1].name}        {[I2].name}    I1与I2是实例
（txt格式箭头省略）
所有对象都是命名空间，继承搜索顺序：由下往上，由左到右
#############################################################################
属性继承搜索：
  object.attribute
  找出attribute首次出现的地方，先搜索objet，然后是该对象上的所有类，由下往上，由左到右；属性访问就是搜索类树，称此为继承搜索。
  搜索树中，树中位置较高的类称为父类，较低的类称为子类，子类可能会在其内部重新定义父类的内容，从而覆盖父类的行为。
############################################################################# 
类和实例：
  两种不同的对象，主要目的都是作为一种命名空间（即变量封装-可以附加属性的地方）
  通过属性继承搜索，I2.w转换为C3.w
  如果I2.w引用的是一个函数调用，其实际意义是调用了C3.w()来处理I2，Python会自动将I2.w()调用映射为C3.w(I2)调用，同时传入该实例作为继承的函数的第一位参数(self)
#############################################################################
编写树类：
  每个class语句会生成一个新的类对象
  每次类调用时，就会生成一个新的实例调用
  实例自动链接到创建他们的类
  类连接到父类的方式是，将父类列在class头部的括号内；括号从左至右的顺序决定树中的次序
  附加在实例上的属性只属于那些实例，附加在类上的属性则由所有子类和实例共享
############################################################################# 
运算符重载：
  __init__方法的效果就是在创建实例时初始化，可以继承，_init_也成为构造函数
  以双下划线命名的方法(__X__)是特殊的钩子；映射关系固定不变
  当实例出现在内置运算中时，方法会被自动调用
  类可以重载绝大多数内置的类型运算
  默认的运算符重载方法既不存在也不需要
  运算符重载可以继承
  __init__会在创建新的实例时被调用
  __add__会在+表达式时被调用
  __str__会在打印一个对象的时候被调用
class ThirdClass(SecondClass):
  def __init__(self, value):
    self.data = value
  def __add__(self, other):
    return ThirdClass(self.data+other)
  def __str__(self):
    return '[ThirdClass: %s]' % self.data
  def mul(self, other):
    self.data *= other

a = ThirdClass("abc")
a.display()    # Current value = "abc"
print(a)      # [ThirdClass: abc]

b = a + "xyz"
b.display()    # Current value = abcxyz
print(b)      # [ThirdClass: abcxyz]

a.mul(3)
print(a)      # [ThirdClass: abcabcabc] 
#############################################################################
类对象提供的默认行为：
  class语句创建类对象并且将其赋值给一个名称
  class语句内的赋值语句会创建类的属性：class语句内的顶层的赋值语句（不是嵌套在def之内）会产生类对象中的属性。执行完class语句，类的属性访问：object.name
  类属性提供了对象的状态和行为
#############################################################################
实例对象是具体的元素：
  像函数那样调用类对象会创建新的实例对象
  每个实例对象继承了类的属性并获得了自己的命名空间；一开始是空的但是会继承类对象的属性
  在方法内对self属性做赋值运算会产生每个实例自己的属性
#############################################################################
class FirstClass:
  def setdata(self, value):
    self.data = value        # self is the instance
  def display(self):
    print(self.data)
x = FirstClass()
y = FirstClass()
  本程序中没有顶层的赋值语句
  到此一共生成了三个对象（三个相连接的命名空间），两个实例对象一开始是空的，data在被setdata赋值前，在内存中不存在。
x.setdata("King Arthur")
y.setdata(3.14159)
  x和y本身没有setdata属性，是通过继承搜索，继承是在属性点号运算时发生的
  在FirstClass的setdata函数中，传入的值被赋给了self.data；self会自动引用当前处理的实例，所以值被储存在了实例的命名空间。
  可以在类方法函数之外对变量名进行赋值运算，从而在实例的命名空间内产生全新的属性，如：
  x.anothername = "spam"
#############################################################################
#############################################################################
#############################################################################
#############################################################################